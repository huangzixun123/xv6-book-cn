# Chapter 3 页表

  页表是OS让每一个进程拥有自己私有的地址空间和内存的最流行的机制。页表决定了内存地址的含义，和那一部分的物理内存可以访问。它允许
xv6隔离不同进程的地址空间和在同一个物理内存中复用他们。页表是一种流行的机制，它提供了间接的层次来让OS可以做一些技巧。xv6做了一点
技巧：将不同地址空间的同一内存，内核保护页和用户栈映射到一个未被映射的页。剩下的章节将来介绍RISC-V提供的页表和xv6是如何使用它的。

## 3.1 页表硬件

  提醒一下(as a reminder)，RISC-V指令(用户和内核)管理虚拟地址。机器的RAM，或者说物理内存，与物理地址相对应。RISC-V页表硬件
通过映射虚拟地址到物理地址，把这两种地址关联起来。

  xv6运行在Sv39 RISC-V，这意味着64位地址的低39位被使用到，高25位没被用到。在Sv39的配置中，RISC-V页表是一个逻辑上的有2^27
个PTEs(page table entries)元素的数组。每一个PTE包含一个44位的PPN(physical page number)和一些标志信息(flag)。页表硬件
用虚拟地址的39位的高27位索引到页表以找到PTE，然后形成一个56位的物理地址，其高44位来自PTE的PPN，低12位来自原来的虚拟地址。图3.1
以页表的逻辑视图展示了PTEs的过程(可以在图3.2观看完整过程)。页表以一块对齐4096字节大小的粒度(granularity)让OS控制虚拟地址到物
理地址的转换。这样的一块叫做页。

  在Sv29 RISC-V，虚拟地址的高25位并没有用来翻译。物理地址也拥有空间来扩展：对于PPN的PTE格式，还有空间再扩展10bit。RISC-V设计
着出于未来技术性的考虑做了这些设计。2^39字节是512GB，这个大小对于跑在RISC-V机器的应用应该足够。2^56应该在未来也是一个足够大的
物理空间，可以用来适应将来的I/O设备和DRAM芯片。如果还需要更多，RISC-V设计者定义了有48bit虚拟地址的Sv48。

  正如图3.2所述，RISC-V CPU翻译虚拟地址分为三步。页表作为一个三个层次的树存储在物理内存中。根树是一个含有512PTEs的页表，包含了
页表页在下一级树的物理地址。这些页都包含有树的最后一层的512个PTEs。

## 3.2  内核地址空间

  xv6对于每一个进程保留一个页表，描述进程的用户地址空间，加上一个单独的页表描述内核地址空间。内核配置了地址空间的布局，让他们自己
以可预测的虚拟地址来访问物理内存和不同的硬件资源。图3.3展示了布局如何映射内核虚拟地址到物理地址中。kernel/memlayout.h声明了
xv6内核布局的常量。

  QEMU模拟计算机，包括从物理地址0x80000000开始的RAM(物理内存)，到0x86400000结束，这在xv6叫做PHYSTOP。QEMU模拟器也包含了
I/O设备如硬盘接口。QEMU以内存映射的控制寄存器暴露设备接口给软件，寄存器在物理地址空间的0x80000000下面。内核可以与设备交流通过
读/写一些特殊的物理地址。例如读或写与硬件设备交流，而不是与内存RAM。第四章将会解释xv6如何与设备交互。

  内核通过直接映射的方法从内存和内存映射设备寄存器获取，也就是说，映射虚拟地址的资源等同于物理地址。例如，内核它自己是位于
KERNBASE=0x80000000在虚拟地址空间和物理内存。直接映射简化了内核代码读或写内存。例如，当fork分配为子进程分配用户内存时，分配器
返回内存的地址；fork直接使用这个虚拟地址当它复制父进程的用户内存到子进程。

  有一些内核虚拟地址没有直接映射。

    trampoline page。它被映射在虚拟地址空间的顶部。用户页表也有相同的映射。第四章介绍trampoline页的作用，在这我们会将它看作页表一个有趣的应用；物理页(包含trampoline代码)在内核虚拟地址空间被映射两次：一次在虚拟地址空间的顶部，一次直接映射。

    内核栈页(kernel stack page)。每一个进程都有自己的内核栈，它被映射在高处为了xv6可以留下一些没有映射的保护页。保护页的PTE是
    无效的(e.g. PTE_V没有设置)，为了如果内核溢出了内核栈，它将会导致一个exception和内核将会panic。溢出栈如果没有保护页将会重写内核内存，导致不正确的操作。所以panic是可选的方案。

  当内核通过高内存映射使用他的栈时，他们可以通过直接映射的地址访问内核。一个替代的设计可能只有直接映射然后在直接映射的地址使用
栈。然而，在这种安排下，使用保护页将涉及取消虚拟地址，否则这些虚拟地址会引用到物理内存，这将很难使用。

  内核使用PTE_R和PTE_X权限映射trampoline页和内核文本。内核会从这些页读和执行指令。内核用PTE_R和PTE_W权限映射其他页，目的是为
了它可以读或者写那些内存。保护页的映射是无效的。

## 3.3 Code:创造地址空间

  xv6大多数管理地址空间和页表的代码在vm.c(kernel/vm.c)。其中的中心数据结构是pagetable_t，它是一个指针指向RISC-V根页表页；
pagetable_t可能是内核页，也可能是进程页表之一。重要函数是walk，它会找虚拟地址的PTE，和mappages，它会给新的映射加上PTE。以
kvm开始的函数用来管理内核页表；以uvm开头的函数管理用户页表；其他函数用来管理两者。copyout和copyin复制数据到用户虚拟地址或从
用户虚拟地址中复制数据，复制来的数据用来做系统调用的参数；他们全在vm.c中因为他们需要清楚的翻译那些地址为了找到对应的物理内存。

  在启动的早期，main调用kvminit(kernel/vm.c:54)，通过使用kvmmake(kernel.vm.c:20)创建出内核页表。这个调用来发生在RISC-V
中xv6使能分页机制(enable paging)前面，因此虚拟地址与物理地址直接关联。kvmmake首先分配一页物理页让存储根页表页。然后调用
kvmmap安装内核需要的翻译机制。这个翻译机制包括内核指令，数据，物理内存直到PHYSTOP，和内存实际是设备的范围。Proc_mapstacks
(kernel/proc.c:33)分配给每一个进程一个内核栈。它调用kvmmap映射每一个栈到KSTACK生成的虚拟地址上，这会流出一个空间给无效的栈
保护页。

  kvmmap(kernel/vm.c:12)调用mappages(kernel/vm.c:138)，它会安装映射到从虚拟地址范围到相应物理内存范围的页表上。对于在页区
间范围内的每一个虚拟地址它都会独立的做这件事。对于每一个被映射的虚拟地址，mappages调用call来找到对应地址的PTE地址。然后它初始化
PTE来存储相应的PPN，相应的权限(PTE_W,PTE_X或PTE_R)和PTE_V来标志PTE有效(kernel/vm.c:153)。

  walk(kernel/vm.c:81)通过假装查找虚拟地址的PTE来模仿(mimics)RISC-V分页硬件(图3.2)。walk每次当时的3级页表下降9位。每次它
用虚拟地址的9位地址来查找要么是下一层页表或最后一页(kernel/vm.c:87)。如果PTE无效，即所需的那一页还没有被分配；如果alloc参数被
设置了，walk分配一个新的页表然后把它的物理地址放在PTE中。它返回树中低层次PTE的地址。(kernel/v,.c:97)

  上面的代码依赖于被直接映射到内核虚拟地址空间的物理内存。例如，当walk下降到页表的下一层时，它会从下一层页表的PTE中拿出物理地址，
然后使用那地址作为虚拟地址来拿到下一层的PTE(kernel/vm.c:87)。

  main调用kvminithart(kernel/vm.c:62)来安装内核页表。它将根页表页的物理地址到寄存器satp。之后，CPU将会通过内核页表翻译地
址。既然内核使用直接映射，下一条指令的地址将会映射到正确的物理内存地址。

  每一个RISC-V CPU会缓存PTE到TLB中。当xv6改变页表时，它必须告诉CPU使对应的TLB条目无效
(invalidate corresponding cached TLB entries)。如果不这样的话，那么在稍后的某一刻，TLB可能会使用老的缓存映射，指向物理页
同时意味着也被分配给其他进程，结果，进程可能会乱写(scribble)其他进程内存。RISC-V有sfence.vma指令来刷新当前CPU的TLB。当重新加
载satp寄存器后，xv6执行kvminithart中的sfence.vma，然后在返回用户空间之前，tramploine中的代码切换回用户页表(kernel/
trampoline.S:79)。

  为了避免刷新所有的TLB，RISC-V CPU可能支持地址空间标识符(ASIDs，address space identifiers)。内核可以只刷新特定地址空间的
TLB。

## 3.4 物理内存分配

  内核必须在运行时为页表、用户内存、内核栈和管道缓存分配和释放物理内存。

  xv6使用在kernel的结束处和PHYSTOP之间的物理内存作为运行时的分配。每一次分配或释放4096字节大小的页。通过将页面串在一起，来跟踪
哪一个页面被释放。分配包括从链表删除页面；释放页面包括将页面串到链表中。

## 3.5 Code: 物理内存分配

  分配器的代码位于kalloc.c(kernel/kalloc.c:1)。分配器的数据结构是free链表，即可以用来分配的物理内存。每一个空闲链表的元素是
struct run(kernel/kalloc.c:17)。分配器从哪里获取内存来放置数据结构呢？它将每一个空闲页run结构存储在它自己的空闲页中，因为没
有其他需要存储的。空闲链表由spin lock保护。链表和锁被包装在一个结构体内用来保证保护结构体里面的字段。在现在，暂时忽略错和调用
acquire和release；第六章将会介绍。