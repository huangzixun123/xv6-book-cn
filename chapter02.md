# Chapter 2  操作系统架构
  对于操作系统来说，一个关键要求是其要同时支持多项活动。例如，我们可以使用第一章所描述的系统调用fork创建一个新的进程。操作系统
必须在这些进程之间将计算资源分时共享出去(**multiplexing**)。例如，即使进程的数量多于CPU的数量，OS必须确保所有进程都有机会执
行。操作系统也需要在进程之间创建出一种隔离机制(**isolation**)，这是因为，如果一个进程出现了bug和故障，它不应该影响到其他与该进
程无关的进程。然而，如果完全的隔离，又太强了，因为有时候进程也需要交互(**interaction**)；管道就是一种例子。因此，操作系统必须满
足三种要求，multiplexing，isolation，interaction。

  这一章提供了一个概览，主要讲解操作系统是如何被组织起来实现上述的三个要求的。已经证明了有许多种方法可以实现，但本书主要讲解主流实
现--宏内核(**monolithic kernel**)，在许多类Unix系统中，都是这种实现。这一章同时介绍了xv6的进程（它是xv6中的隔离单元）以及
xv6启动时创建第一个进程的过程。

  xv6运行在多核RISC-V微处理器上，并且它的大部分底层函数实现都是用的RISC-V。RISC-V是64位CPU，xv6是用"LP64"C所写的，
即C语言的long类型和pointers类型(64位)，但int是32位。本书假设读者有一些机器层面的编程经验，且在介绍RISC-V时有一定的感觉。对于
RISC-V，你可以参考**The RISC-V Reader: An Open Architecture Atlas**。用户级别的ISA和特权指令集可以参考官方文档。

  完整计算机中的CPU被硬件包围，其中主要是以I/O接口的形式。xv6是为了qemu的'- machine virt'选项模拟硬件而编写。它包括RAM，
包含引导代码的ROM,连接到用户键盘和屏幕的串行连接(serial connection)，和存储用的硬盘(disk)。

## 2.1 物理资源的抽象

  当看到OS时，第一个可能会问的问题是为什么要有它？那是因为，我们可以实现系统调用为一个库(**library**)，供应用程序调用。在这种方
案下，每个应用程序可以拥有一个满足自己需求的库。应用可以直接访问硬件资源，并合理利用这些资源(e.g，达到高性能或可预测的表现)。一
些嵌入式系统或者实时系统就是以这种方式实现的。

  库(**library**)方法的缺点，主要在于当多个应用运行时，应用必须表现良好。例如，每一个应用必须周期性的放弃CPU为了其他应用可以运
行。这样一种合作式的时间分享(**cooperative time-sharing**)方案只有在每个程序都信任其他程序没有bug时才会成立。比较典型的是，
应用程序不相信其他程序，并且认为其他程序有bug，所以人们想要一个比合作式方案隔离性更强的方案。

  为了实现强隔离，禁止应用直接访问硬件资源是一种有效的选择，并且可以将资源抽象成服务。例如，Unix应用只通过文件系统open、read、
、write，还有系统调用close与存储服务交互，而不是直接的读或写硬盘。这给应用程序提供了文件名的便利性，并且允许操作系统管理硬盘。
即使隔离已经不是问题了，想要互相交互的程序(或只是想要保持隔离的程序)更倾向与找到一个更方便的抽象文件系统，而不是直接操作硬盘。

  同样，Unix在进程之间切换CPU并且根据需要保存和恢复寄存器的信息，这样应用不会意识到CPU时间被分享了。这种透明性(transparency)
使得操作系统可以在应用程序无限循环的情况下，也能将CPU分享给进程。

  有一个另外的例子，Unix进程使用exec来构建出它们的内存镜像，而不是直接操作物理内存。这允许操作系统决定哪个地方放哪个进程；如果内
寸紧张，操作系统可以将进程数据存在硬盘中。Exec还会用户提供了一个文件系统来便利的存储可执行程序镜像。

  Unix进程之间的许多交互的形式都是通过文件描述符来实现的(file descriptor)。文件描述符不仅抽象了许多细节，也定义了一种简化了进
程间交互的方式。例如，如果管道中一个应用运行出现错误了，内核将会产生一个end-of-line信号给管道中的下一个应用。

  图1.2中的系统调用接口，是被精心设计后，提供给编程者编程的便利和强隔离性的可能。Unix接口并不是唯一种抽象资源的方式，但已经被
证明是一种很好的方式。 

## 2.2 用户模式(User mode)，监管模式(supervisor mode)，和系统调用

  强隔离机制需要在应用程序和操作系统之间有一个明显的边界。如果应用出错了，他不应该影响到OS或其他应用。换句话说，操作系统应该能够
清理掉运行出错的应用，继续运行其他正常的应用。为了实现强隔离，操作系统必须让应用程序无法修改甚至无法读OS的数据结构和指令，和让应
用程序无法访问其他进程的内存。

  CPU为强隔离提供了硬件支持。例如，RISC-V有三种模式:machine mode,supervisor mode,user mode，这三种模式下，CPU都可以执行
指令。在机器模式下执行的指令具有完全的权限；CPU在机器模式下开始运行。机器模式主要用于配置电脑。xv6在机器模式下执行很少的命令后就
切换都监管模式。

  在监管模式，CPU允许执行特权指令，例如，允许中断指令、静止中断指令，读或写用来存储页表的寄存器指令等等。如果用户模式下的应用程序
试图执行特权指令，CPU不会执行该指令，而是切换到监管模式并终止该应用，因为它做了它不应该做的事。应用运行在用户空间，只能执行用户模
式指令，在监管模式的软件运行在内核模式，并且能够执行特权指令。在内核模式下运行的软件叫做内核(**kernel**)。

  如果一个应用想要调用一个内核函数，必须先转换到内核，也就是说，应用无法直接调用内核函数。CPU提供了一条特殊的指令，它能够从用户模
式切换到监管模式，并且进入到内核指定的一个入口点（RISC-V中，该指令是ecall）。一旦进入到监管模式，内核将会验证系统调用的参数，决定
该指令能否被执行。切换到监管模式后，进入内核指定的入口点很重要。若应用可以决定进入内核的入口点，恶意程序(maliciousapplication)可能会跳过验证参数的代码。

## 2.3 内核结构

  操作系统设计的一个重要问题是操作系统的哪一部分应该运行在监管模式。一种方法是整个操作系统都放在内核中，所以系统调用的所有实现都是
运行在监管模式。这种模式被称为宏内核(**monolithic kernel**)。

  在这种架构下，OS拥有所有硬件权限。这种架构使得OS设计者不用考虑操作系统的哪一部分不应该拥有完整的硬件权限。而且，这也使得操作系
不同部分能够更方便的协作。例如，操作系统可能会有一个buffer cache在文件系统和虚拟内存系统的共享。

  宏内核架构的主要缺点是，操作系统的不同部分会太复杂，因为很容易OS开发者就会写出bug。在宏内核中，写出bug是致命错误的，因为监管模
式下的错误会导致整个内核无法运行。如果内核停止运行，电脑将会停止工作，应用也会停止运行。电脑必须重启。

  为了减少内核犯错的风险，OS设计者可以将部分OS代码运行在监管模式，部分运行在用户模式。这种架构叫做微内核(microkernel)。

  图2.1介绍了微内核的设计，文件系统在用户层面上运行。以进程运行的OS服务被叫做服务器。为了允许应用与文件系统交互，内核提供了一种进
程间通信的机制，从用户层面上发信息给另一个进程。例如，如果应用想要shell读或写文件，它会发信息给文件服务器然后等待回应。

  在微内核中，内核接口由启动应用、发送消息、访问设备硬件等底层函数构成。这种架构允许内核相当简单，操作系统的大部分都运行在用户层面
的服务器。

  在现实中，微内核和宏内核都非常流行。许多Unix内核是宏内核的。例如，Linux就是一种宏内核架构，虽然有一些OS函数运行在用户层面上。
Linux对于操作系统密集型(OS-intensive)提供了高性能，部分原因是因为内核的子系统可以被紧密集成。

  像Minix、L4、QNX的操作系统被组织成一个带有服务器的微内核，并且已经广泛应用许多嵌入式设备。L4的变体，seL4，它足够小，并且已经
被被验证内存和其他安全特性的安全。

  关于宏内核和微内核那种更好，开发者有很多的争论，但也没有总结性的结论，说哪种比较好。换句话说，这取决与如何定义“好”，更快的表现？
更小的代码数量？内核的可靠性？整个OS的可靠性(包括用户层面的服务)等等。

  事实上，实践上的考虑可能会比哪种架构更好更重要。一些OS是微内核的，但是为了性能的考虑，将用户层面的服务在内核空间上运行。一些OS
是宏内核的只是因为它开始就是这样写的，并且没有什么动力换成微内核架构，因为新功能比为了适应微内核设计而重写操作系统更重要。

  本书的看法，微内核和宏内核都共享许多关键的想法。他们实现系统调用，使用页表机制，处理中断，支持进程，使用锁来控制并发，实现文件系
统等等。本书主要集中这些核心思想。

  xv6是宏内核架构，就像大多数Unix操作系统。因此，xv6内核接口对应操作系统接口，内核实现了整个操作系统。因为xv6没有提供很多服务，
它的内核比一些微内核更小，但xv6是宏内核的。

## 2.4 Code: xv6架构

  xv6内核代码在**kernel/**目录下。源文件被分成许多文件，一种模糊概念的模块化；图2.2列出了这些文件。内部模块的接口被定义在
**defs.h(kernel/defs.h)**。

## 2.5 进程概览

  xv6的隔离单元是进程。进程的抽象防止一个进程破坏或监控其他进程的内存、CPU、文件描述符等等。它同时也防止进程破坏它自己的内核，
因此进程无法颠覆(subvert)内核的隔离机制。内核在实现进程抽象需要十分小心，因为一个有bug或恶意的应用可能会欺骗内核或者硬件，让
他们做了一些不好的事。内核实现进程所使用的机制包括用户/监管模式标志、地址空间、线程时间切分(time-slicing of threads)。

  为了帮助强化隔离，进程抽象给了程序一种错觉(illusion)使得程序以为自己拥有私有的机器。进程给程序提供了看起来像是私有的内存系统
或地址空间，这些空间其他进程无法读或写。进程也给程序提供了看起来像是私有的CPU来执行程序指令。

  xv6使用页表(由硬件实现)来给每一个进程自己的地址空间。RISC-V页表翻译(或映射)虚拟地址(RISC-V指令管理的地址)到物理地址(CPU
发送给主存的地址)上。

  xv6为每个进程保留了一个页表，这样每个进程有自己的地址空间。正如图2.3所示，地址空间包括从虚拟地址0开始的用户内存。首先是指令、
然后是全局变量，stack，最后是heap(为了进程可以根据需要而扩展)。有许多因素会限制到进程地址空间的大小：RISC-V的指针是64位宽；
在页表查询虚拟地址时，硬件只使用了低39位，而xv6只使用了38位。因此，最大的地址时 2^38-1=0x3fffffffff,也就是MAXVA
(kernel/riscv.h)。在地址空间的顶部，xv6保留了一页给trampoline和一页映射进程的trapframe。xv6使用这两页来进入内核和退出内
核；tramploine包括进入和退出内核的代码，map trapframes对于用户进程的保存和恢复很有必要，我们将会在第四章讲解。

  xv6内核为每个进程维护(maintain)很多状态，它会收集这些状态后放进**struct proc**(kernel/proc.h)。进程最重要的内核状态是
页表，内核栈还有运行状态。我们将会使用**p->xxx**来引用**proc**结构体的元素；例如**p->pagetable**就是指向进程页表的指针。

  每一个进程都有一个线程来执行进程的指令。线程可以被挂起然后稍后再恢复。为了透明地在进程间切换，内核会挂起当前正在运行的线程，然后
恢复其他进程的线程。大多数线程的状态(本地变量、函数调用的返回地址)被存储在线程的栈。每个进程有两个栈，用户栈和内核栈(p->kstack)
当进程在执行用户指令时，只有用户栈在使用，此时它的内核栈是空的。当进程进入内核(由于系统调用或者中断)，内核代码会在内核栈上执行。
当进程在内核中，它的用户栈仍然保留了保存的数据，但不会被使用。进程的线程交替使用用户栈和内核栈。内核栈是独立的(separate)(且不受到用户代码的影响)，因此内核可以执行即使进程已经破坏了用户栈。

  进程可以通过使用RISC-V**ecall**指令来使用系统调用。该指令会提升硬件特权等级和改变程序计数器(pc)，使其指向内核定义的入口点。
入口点的代码会切换到内核栈，执行实现系统调用的内核指令。当系统调用完成后，内核切换回用户栈，通过调用**sret**返回用户空间，此时
硬件特权级别降低，继续执行系统调用后的用户指令。进程的线程可能会阻塞在内核中等待I/O，当I/O执行完后继续执行。

  **p->state**表示进程状态:是否已经被分配，是否已经准备好运行，正在运行？正在等待I/O？或者已经退出。
  
  **p->pagetable**以RISC-V期望的格式保存进程的页表。在用户空间执行进程时，xv6会让页表硬件使用进程的**p->pagetable**。进程
页表也会记录物理页分配给进程内存时的地址。
 
  总之，进程包括了两种设计思想：地址空间给予每个进程拥有自己内存的幻觉，线程给予进程拥有自己CPU的幻觉。在xv6中，进程包括一个地址
空间和一个线程。真实的OS可能会有多个线程来充分利用多CPU。

## 2.6 Code:启动xv6，第一个进程还有系统调用

  为了让xv6更加具体，我们将会简述内核是如何开始的和运行第一个进程。

  当RISC-V电脑启动时，首先初始化它自己，执行boot loader(存储在ROM)。boot loader将xv6内核载入内存。然后，在机器模式下，CPU
在**_entry**(kernel/entry.S)执行xv6。RISC-V禁止页表机制，此时虚拟地址直接映射为物理地址。
  
  loader将内核加载到物理地址0x80000000的内存中。为什么不是0的原因是因为它下面的空间用来放I/O设备。

  为了让xv6可以运行C代码，指令在**_entry**设置了一个栈。xv6为初始栈定义了一个空间，**stack0**，在**start.c**
(kernel.start.c)中。在_entry的代码加载栈指针寄存器(sp)，地址为stack0+4096，即栈的顶部。因为RISC-V的栈是往下长的。现在，内
核拥有栈了，_entry在start调用C代码。
  start函数执行一些仅在机器模式下才允许的配置，然后切换到监管模式。为了进入监管模式，RISC-V提供了mret指令。该指令经常用来从监管
模式先前的调用返回到机器模式。start不会从这样的调用中返回，而是：将寄存器mstatus的值设置为进入supervisor前的特权模式，将寄存器
mepc的值设置为main的返回地址，将0写入页表寄存器satp用来关闭监管模式的虚拟地址翻译，将所有中断和异常委托给监管模式处理。

  在进入监管模式之前，start会执行一下任务：它会给时钟芯片编程，让他产生时间中断。通过这种方式，start通过调用mret返回监管模式。这
会让pc的值设置为main的地址。

  当main函数初始化了一些设备和子系统后，它使用userinit创建出第一个进程。第一个进程会执行一小部分的RISC-V汇编程序，实现xv6的第
一个系统调用。initcode.S将exec系统调用的值，SYS_EXEC，加载到寄存器a7，然后调用ecall重新进入内核。

  内核会使用寄存器a7的值来调用对应的系统调用。系统调用表(kernel/syscall.c:108)将SYS_EXEC映射到sys_exec。正如第一章所看到
的,exec会用新的程序来替换当前进程的内存和寄存器的值。

  一旦内核完成exec，它在init进程返回用户空间。如果有需要的话，Init(user/init.c)会创建一个新的控制台设备，然后将其作为文件描述
符号0,1,2。然后在控制台开始新的shell。系统启动！


## 2.7 安全模型

  你可能会好奇OS是如何解决带有bug或是恶意性的代码。因为OS解决恶意代码比解决因为意外而出了bug的代码更加难，所以有理由将这个话题看
做是跟安全相关的问题。下面将会从一种高层次的视角来看待OS设计中一些典型的安全假设和目标。

  OS必须假设用户进程的代码会尽最大的努力来破坏内核和其他进程。用户代码可能会尝试解引用(dereference)不属于它地址空间的地址；它可
能会尝试执行一些用户级别不能执行的RISC-V指令；它可能会尝试读或写一些RISC-V控制寄存器；它可能会尝试直接访问硬件设备；他可能会尝试
传一些巧妙的数给系统调用来尝试欺骗内核，让它做一些愚蠢或让系统崩溃的事。内核的目标是限制用户进程，让它只能读/写/执行它自己内存，使
用32位的通用寄存器，只能以系统调用允许的方式来影响内核和其他进程。内核必须避免其它的操作。这通常就是内核设计的绝对要求。

  对内核的代码期望是十分不同的。内核代码假设由善意(well-meaning)和仔细的程序员编码。对于内核的期望是没有bug和任何的恶意代码。这
个假设影响了我们如何分析代码。例如，一些内核函数(e.g.,spin locks)如果使用不当的话会导致一些严重的问题。当我们测试一些特定片段的
内核代码时，我们想要说服自己它的行为是正确的。我们假设内核代码是在符合内核函数和数据结构下被正确编写的。在硬件层面上，也假设RISC-V
CPU、RAM、disk等也跟文档说的一样，没有bug。

  当然，在现实生活中并没有那么简单。很难防止一些巧妙的用户代码通过消耗内核保护资源，如硬盘空间、CPU时间等使得系统不可用。通常，几
乎不可能写出没有bug的代码或没有bug的硬件；如果恶意代码的作者们意识到内核或硬件的bug，他们会利用它。设计一些保护措施，如断言
(assertion)、类型检查(type checking)、栈的保护页，来防止内核出现bug很有必要。最后，用户和内核代码的区别有时是模糊的
(blurred)：一些有特权的用户级别进程会提供一些必要的服务并有效的成为OS的一部分，并且在一些OS中，有特权的用户代码可以插入到
内核中(如Linux的可加载内核模块(loadable kernel modules)).